# Level 13

## 目的
ユーザー `flag13` の権限で `getflag` コマンドを実行し、フラグを取得する。

## 手順と解説

### 1. 調査

`level13` ユーザーでログイン後、SetUIDバイナリ `level13` を確認します。

```bash
ls -l level13
./level13
```
実行すると以下のメッセージが表示されます。
```text
UID 2013 started us but we we expect 4242
```
プログラムは実行ユーザーのUIDをチェックし、それが `4242` でない場合に終了してしまうようです。

### 2. 解析と戦略

`strings` コマンドや `gdb` での逆アセンブル結果から、プログラム内部にトークン生成ロジック（`ft_des` 関数など）が含まれており、外部ファイル（`flag` ファイルなど）を読み取っているわけではないことが推測できます。
つまり、SetUIDの権限は必須ではなく、**UIDチェックさえ回避できれば**、誰が実行してもトークンが表示される仕組みになっています。

GDBを使用して実行中のメモリ（レジスタ）を書き換え、UIDチェックを騙すことにします。

### 3. GDBによるエクスプロイト

バイナリを一行ずつ（一命令ずつ）確認しながら進める詳細な手順は以下の通りです。

1.  **GDBの起動と準備**:
    ```bash
    cp level13 /tmp/level13_copy
    gdb /tmp/level13_copy
    ```

2.  **デバッグの実行**:
    GDBプロンプト内で以下のコマンドを順に実行します。
    ```gdb
    (gdb) b main            # main関数の先頭にブレークポイントを設定
    (gdb) display/i $pc
    (gdb) r                 # プログラムを実行
    (gdb) i r
    ```
    ※ `layout src` はソースコードがある場合に有効ですが、今回のようにバイナリのみの場合は `layout asm` が最適です。

3.  **ステップ実行と値の書き換え**:
    `ni` (Next Instruction) コマンドで、`getuid` 呼び出しの直後まで進めます。
    ```gdb
    (gdb) ni                # <+14> cmp $0x1092,%eax の行に来るまで繰り返す
    (gdb) set $eax=4242     # eaxレジスタ（UIDの結果が入る）を期待される値 4242 に書き換え
    (gdb) c                 # 実行を継続
    ```

### 4. 結果

UIDチェックが正常にパスしたと判定され、プログラム内部のロジックによってトークンが表示されます。

```text
your token is 2A31L79asukciNyi8uppkEuSx
```

## 結果

### トークン (Flag)
`2A31L79asukciNyi8uppkEuSx`
